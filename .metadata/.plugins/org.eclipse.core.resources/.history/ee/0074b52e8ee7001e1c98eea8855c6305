package org.xtext.fetaml.cpp.pkg

import org.xtext.fetaml.fetaml.DeploymentDefinition
import org.xtext.fetaml.fetaml.NodeInstance
import org.xtext.fetaml.fetaml.PlatformInstance
import org.xtext.fetaml.fetaml.ProcessInstance
import org.xtext.fetaml.fetaml.SystemNodeReference
import org.xtext.fetaml.cpp.process.Process
import org.xtext.fetaml.cpp.process.ProcessNode
import org.xtext.fetaml.cpp.system.SystemInstance
import org.xtext.fetaml.model.AbstractFetaMLPackage
import org.xtext.fetaml.model.FetaMLPackageFactory
import org.xtext.fetaml.cpp.pkg.launch.LaunchConfigurationBuilder
import org.xtext.fetaml.cpp.system.DeploymentInfo

package class Deployment {
	val AbstractFetaMLPackage pkg
	val DeploymentDefinition definition
	val Iterable<SystemInstance> systems
	val Iterable<PlatformInstance> platforms
	
	static def fromFetaML(DeploymentDefinition definition) {
		new Deployment(definition)
	}
	
	private new(DeploymentDefinition deployment) {
		this.definition = deployment
		this.pkg = FetaMLPackageFactory::fromFetaML(definition.package)
		this.platforms = definition.platforms
		this.systems = definition.systems.map[sysRef| SystemInstance::fromFetaML(sysRef)]
	}
	
	def getLaunchFiles() {
		platforms.map[platform|			
			val lfBuilder = new LaunchConfigurationBuilder()
			
			val systemLaunchActions = this.systems.flatMap[getAllLaunchActionsFor(DeploymentInfo::fromFetaML(this.definition), platform)]
			val processLaunchActions = getProcessesToBeStartedForPlatform(platform).map[launchConfig]
			
			for(launchAction : systemLaunchActions + processLaunchActions) {
				lfBuilder.register(launchAction)
			}
			
			lfBuilder.launchConfiguration.toLaunchFile(pkg, platform.name)
		]
	}
	
	def getExecutables() {
		this.platforms
			.flatMap[getProcessesToBeStartedForPlatform]
			.map[process| process.executable]
	}
	
	// TODO exposing this methode is a workaround to allow the registration of the topic_tools package as dependency to the package-manifest
	package def requiresTopicTools() {
		this.systems.exists[]
	}
	
	private def getProcessesToBeStartedForPlatform(PlatformInstance platform) {
		definition.processMappings.groupBy[platform].get(platform).map[createProcessFrom(process)]
	}
	
	private def createProcessFrom(ProcessInstance pi) {
		val processesNodes = pi?.nodes?.map[ni|
			val x = systems.map[systemHierarchyRoot|
				systemHierarchyRoot.getSystemNodeInstanceForFetaML(ni.instance)
			].head
			
			new ProcessNode(x, findFunctionMappingsForProcessesNode(ni))
		]
		
		val proc = new Process(
			definition.package,
			pi.name,
			processesNodes
		)
		
		return proc
	}
	
	private def findFunctionMappingsForNodeInstance(NodeInstance ni) {
		definition.functionMappings.filter[mapping|
			mapping.node.instance.equals(ni)
		]
	}
	
	private def findFunctionMappingsForProcessesNode(SystemNodeReference nodeRef) {
		findFunctionMappingsForNodeInstance(nodeRef.instance)
	}
}
