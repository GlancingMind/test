package org.xtext.fetaml.validation

import org.eclipse.xtext.validation.EValidatorRegistrar
import org.eclipse.xtext.validation.Check
import org.xtext.fetaml.fetaml.DirectConnection
import org.xtext.fetaml.fetaml.FetamlPackage
import org.xtext.fetaml.fetaml.ForwardConnection
import org.xtext.fetaml.fetaml.Publisher
import org.xtext.fetaml.fetaml.ServiceConsumer
import org.xtext.fetaml.fetaml.ServiceProvider
import org.xtext.fetaml.fetaml.Subscriber
import org.xtext.fetaml.fetaml.SystemDefinition
import static extension org.xtext.fetaml.extensions.PortExtensions.*
import static extension org.xtext.fetaml.extensions.SystemExtensions.*
import org.xtext.fetaml.fetaml.Port
import java.util.Set

class SystemValidator extends AbstractFetamlValidator {
	
	/** This is left blank as specified in documentation of {@link org.eclipse.xtext.validation.ComposedChecks} */
	override register(EValidatorRegistrar registrar) {
		
	}
	
	@Check
	def checkEndNameEqualsSystemName(SystemDefinition definition) {
		if (!definition.name.equals(definition.endName)) {
			error("Name and end name must be equal",
				FetamlPackage::Literals::DEFINITION_NAME__END_NAME,
				"InvalidName"
			)
		}
	}
	
	@Check
	def checkForDuplicateDirectConnections(SystemDefinition definition) {
		val mappings = <Pair<Port, Port>>newHashSet
		definition.connections.forEach[connection, featureIndex|
			// NOTE the order of source and destination is irrelevant. Therefore check the reversed form too!
			if (!mappings.add({connection.port1.port -> connection.port2.port}) 
				|| !mappings.add({connection.port2.port -> connection.port1.port})
			) {
				warning(
					'''Connection: «connection.stringify», is a duplicate''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__CONNECTIONS,
					featureIndex,
					"DuplicateConnection"
				)
			}
		]
	}
	
	@Check
	def checkForDuplicateForwardings(SystemDefinition definition) {
		val mappings = <Pair<Port, Port>>newHashSet
		definition?.forwardings?.forEach[forwarding, featureIndex|
			// NOTE the order of source and destination is irrelevant. Therefore check the reversed form too!
			if (!mappings.add({forwarding.port1.port -> forwarding.port2.port})
				|| !mappings.add({forwarding.port2.port -> forwarding.port1.port})
			) {
				warning(
					'''Forwarding: «forwarding.stringify», is a duplicate''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__FORWARDINGS,
					featureIndex,
					"DuplicateForwarding"
				)
			}
		]
	}
	
	/** 
	 * Checks if a connection is invalid or not. Throws an error if a port is connected to itself or 
	 * when the ports are not of the same type, with differing directions.
	 */
	@Check
	def void check(DirectConnection connection) {
		val p1 = connection.port1.port
		val p2 = connection.port2.port
		
		if (p1 === p2) {
			error("A port can't be connected to itself", FetamlPackage::Literals::CONNECTION__PORT2,
				"InvalidDirectConnection")
		}
		else if (!(p1 instanceof Publisher && p2 instanceof Subscriber)
				&& !(p1 instanceof Subscriber && p2 instanceof Publisher) 
				&& !(p1 instanceof ServiceConsumer && p2 instanceof ServiceProvider)
				&& !(p1 instanceof ServiceProvider && p2 instanceof ServiceConsumer)) {
			error(
				'''Connecting a «p1.eClass.name» to a «p2.eClass.name» is not allowed.''',
				FetamlPackage::Literals::CONNECTION__PORT2,
				"InvalidDirectConnection"
			)
		}
		else {
			if (!p1.type.equals(p2.type)) {
				val msg = '''Port «p1.name» is of different type («p1.type.name»), then port «p2.name» («p2.type.name»)'''
				error(msg, FetamlPackage::Literals::CONNECTION__PORT2, "InvalidDirectConnection")
			}
		}
	}
	
	/** 
	 * Checks if a forwarding is invalid or not. Throws an error if a port is connected to itself or 
	 * when the ports are not of the same type and direction.
	 */
	@Check
	def void check(ForwardConnection connection) {
		val p1 = connection.port1.port
		val p2 = connection.port2.port
		
		if (p1 === p2) {
			error("A port can't be connected to itself",
				FetamlPackage::Literals::CONNECTION__PORT2,
				"InvalidForwardConnection"
			)
		}
		else if (!p1.eClass.equals(p2.eClass)) {
			error('''Forwarding a «p1.eClass.name» as a «p2.eClass.name» is not allowed.''',
				FetamlPackage::Literals::CONNECTION__PORT2,
				"InvalidForwardConnection"
			)
		}
		else {
			if (!p1.type.equals(p2.type)) {
				val msg = '''Forwarded port «p1.name» is of different type («p1.type.name»), then «p2.name» («p2.type.name»)'''
				error(msg, FetamlPackage::Literals::CONNECTION__PORT2, "InvalidForwardConnection")
			}
		}
	}

	@Check
	def checkForDuplicateDataPorts(SystemDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.dataPorts.forEach[port, featureIndex|
			if (!alreadyDefinedNames.add(port.name)) {
				error('''A data port with the name: «port.name» is already defined''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__DATA_PORTS,
					featureIndex,
					"DuplicateDataPort"
				)
			}
		]
	}

	@Check
	def checkForDuplicateServicePorts(SystemDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.servicePorts.forEach[port, featureIndex|
			if (!alreadyDefinedNames.add(port.name)) {
				error('''A service port with the name: «port.name» is already defined''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__DATA_PORTS,
					featureIndex,
					"DuplicateServicePort"
				)
			}
		]
	}

	@Check
	def checkForDuplicateNodeInstances(SystemDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.nodeInstances.forEach[node, featureIndex|
			if (!alreadyDefinedNames.add(node.name)) {
				error('''A node instance with the name: «node.name» is already defined''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__NODE_INSTANCES,
					featureIndex,
					"DuplicateNodeInstance"
				)
			}
		]
	}

	@Check
	def checkForDuplicateSubsystems(SystemDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.subsystems.forEach[system, featureIndex|
			if (!alreadyDefinedNames.add(system.name)) {
				error('''A subsystem with the name: «system.name» is already defined''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__SUBSYSTEMS,
					featureIndex,
					"DuplicateSubsystem"
				)
			}
		]
	}
	
	@Check
	def errorWhenSystemUsesItselfAsSubsystem(SystemDefinition definition) {
		definition.subsystems.forEach[subsystem, featureIndex|
			if (subsystem.type.equals(definition)) {
				error('''A system cannot use itself as subsystem''',
					FetamlPackage::Literals::SYSTEM_DEFINITION__SUBSYSTEMS,
					featureIndex,
					"SystemUsesItselfAsSubsystem"
				)
			}
		]
	}
	
	@Check
	def warnForRecursionWithinSystemInclusion(SystemDefinition system) {
		val cycle = <SystemDefinition>newLinkedHashSet
		val foundCycle = findCycleInSubsystemsOf(system, cycle)
		// Do NOT fire for a system which includes itself. This is done by checkIfSystemUsesItselfAsSubsystem.
		if (foundCycle && cycle.size > 1) {
			warning('''A recursive cycle was detected within the given subsystems: «cycle.map[name].join(" -> ")» -> «system.name»''',
				FetamlPackage::Literals::SYSTEM_DEFINITION__SUBSYSTEMS,
				"CyclicSystemInclusion"
			)
		}
	}
	
	/** 
	 * Traverses a subsystem inclusion graph recursively and stops on the first found cycle.
	 * This function does mutate the given visited set, so that the set will contain the systems in traversed order,
	 * which build an inclusion cycle.
	 * @param child The start system of the inclusion graph.
	 * @param visited Set of already seen systems. Should be an empty list for callers.
	 * @return true when a cycle was found, otherwise false.
	 */
	def boolean findCycleInSubsystemsOf(SystemDefinition system, Set<SystemDefinition> visited) {
		visited.add(system)
		for (subsystemType : system.subsystems.map[type]) {
			if (!visited.contains(subsystemType)) {
				return findCycleInSubsystemsOf(subsystemType, visited)
			} else {
				// found cycle
				return true
			}
		}
		return false
	}
}
