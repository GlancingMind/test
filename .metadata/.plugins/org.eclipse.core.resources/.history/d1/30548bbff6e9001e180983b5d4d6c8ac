package org.xtext.fetaml.validation

import org.eclipse.xtext.validation.EValidatorRegistrar
import org.eclipse.xtext.validation.Check
import org.xtext.fetaml.fetaml.DeploymentDefinition
import org.xtext.fetaml.fetaml.FetamlPackage
import org.xtext.fetaml.fetaml.ProcessInstance
import org.xtext.fetaml.fetaml.Function
import org.xtext.fetaml.cpp.system.SystemInstance
import static extension org.xtext.fetaml.extensions.FunctionExtensions.*
import static extension org.xtext.fetaml.extensions.SystemNodeReferenceExtension.*

class DeploymentValidator extends AbstractFetamlValidator {
	
	/** This is left blank as specified in documentation of {@link org.eclipse.xtext.validation.ComposedChecks} */
	override register(EValidatorRegistrar registrar) {
		
	}
	
	@Check
	def checkEndNameEqualsDeploymentName(DeploymentDefinition definition) {
		if (!definition.name.equals(definition.endName)) {
			error("Name and end name must be equal", FetamlPackage.Literals.DEFINITION_NAME__END_NAME, "InvalidName")
		}
	}
	
	@Check
	def checkForAlreadyUsedSystemName(DeploymentDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.systems.forEach[system, featureIndex|
			if (!alreadyDefinedNames.add(system.name)) {
				error('''A system instance with the name: «system.name» is already defined''',
					FetamlPackage::Literals::DEPLOYMENT_DEFINITION__SYSTEMS,
					featureIndex,
					"NameAlreadyTaken"
				)
			}
		]
	}
	
	@Check
	def checkForAlreadyUsedPlatformName(DeploymentDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.platforms.forEach[platform, featureIndex|
			if (!alreadyDefinedNames.add(platform.name)) {
				error('''A platform instance with the name: «platform.name» is already defined''',
					FetamlPackage::Literals::DEPLOYMENT_DEFINITION__PLATFORMS,
					featureIndex,
					"NameAlreadyTaken"
				)
			}
		]
	}
	
	@Check
	def checkForAlreadyUsedProcessName(DeploymentDefinition definition) {
		val alreadyDefinedNames = <String>newHashSet
		definition.processes.forEach[process|
			if (!alreadyDefinedNames.add(process.name)) {
				error('''A process with the name: «process.name» is already defined''',
					process,
					FetamlPackage::Literals::USER_GIVEN_IDENTIFIER__NAME,
					"NameAlreadyTaken"
				)
			}
		]
	}
	
	@Check
	def checkProccessCanOnlyRunOnOnePlatform(DeploymentDefinition definition) {
		val alreadyDefinedMapping = <String,String>newHashMap
		definition.processMappings.forEach[mapping, featureIndex|
			if (alreadyDefinedMapping.containsKey(mapping.process.name)) {
				val targetPlatform = alreadyDefinedMapping.get(mapping.process.name)
				error('''Process: «mapping.process.name» is already assigned to run on platform: «targetPlatform»''',
					FetamlPackage::Literals::DEPLOYMENT_DEFINITION__PROCESS_MAPPINGS,
					featureIndex,
					"ProcessTargetPlatformAlreadyDefined"
				)
			}
			alreadyDefinedMapping.putIfAbsent(mapping.process.name, mapping.platform.name)
		]
	}
	
	@Check
	def checkNoDuplicateReferencedNodesInProcessInstance(DeploymentDefinition deployment) {
		val alreadyAssignedNodes = <String, ProcessInstance>newHashMap
		deployment?.processes?.forEach[process|
			process?.nodes?.forEach[nodeRef, featureIndex|
				val stringifiedNodeRef = nodeRef.systemPath.join('.')+"."+nodeRef.instance.name
				val prevAssignedProcessInstance = alreadyAssignedNodes.putIfAbsent(stringifiedNodeRef, process)
				if (prevAssignedProcessInstance !== null) {
					val fqNodeName = nodeRef.systemPath.join('.')+'.'+nodeRef.instance.name
					error('''Node: «fqNodeName» is already assigned to process: «prevAssignedProcessInstance.name»''',
						nodeRef,
						FetamlPackage::Literals::SYSTEM_NODE_REFERENCE__INSTANCE,
						featureIndex,
						"ProcessNodeAlreadyReferenced"
					)
				}
			]
		]
	}
	
	@Check
	def checkThatANodeFunctionIsOnlyMappedOnce(DeploymentDefinition definition) {
		val alreadyDefinedMapping = <Function>newHashSet
		definition.functionMappings.forEach[mapping, featureIndex|
			if (!alreadyDefinedMapping.add(mapping.nodeFunction)) {
				val nf = '''«mapping.node.systemPath.join('.')».«mapping.node.instance.name».«mapping.nodeFunction.name»'''
				val df = '''«mapping.device.fromPlatform.name».«mapping.device.instance.name».«mapping.deviceFunction.name»'''
				error('''The function: «nf» is already assigned to the device function: «df»''',
					FetamlPackage::Literals::DEPLOYMENT_DEFINITION__FUNCTION_MAPPINGS,
					featureIndex,
					"NodeFunctionIsAlreadyMappedToSomeDeviceFunction"
				)
			}
		]
	}
	
	@Check
	def checkThatMappedFunctionsHaveMatchingSignature(DeploymentDefinition definition) {
		definition.functionMappings.forEach[mapping, featureIndex|
			val nfSignature = mapping.nodeFunction.signature
			val dfSignature = mapping.deviceFunction.signature
			if (!nfSignature.equals(dfSignature)) {	
				error('''The nodes function signature: "«nfSignature»" does not match the device function signature: "«dfSignature»"''',
					FetamlPackage::Literals::DEPLOYMENT_DEFINITION__FUNCTION_MAPPINGS,
					featureIndex,
					"MissmatchingFunctionSignatures"
				)
			}
		]
	}
	
	@Check
	def errorNodesProcessDoesNotRunOnSpecifiedPlatform(DeploymentDefinition definition) {
		// Key = NodesName, Value = ProcessName
		val nodeNameToProcessNamePairs = definition.processes.flatMap[process|
			process.nodes.flatMap[
				val nodeName = systemPath.join('.') +"."+ instance.name
				#{ nodeName -> process.name}
			]
		] 
		
		// Key = ProcessName, Value = PlatformName
		val processNameToPlatformNamePairs = definition.processMappings.flatMap[
			#{process.name -> platform.name}
		]
		
		definition?.functionMappings?.forEach[mapping|
			val nodeNameWithinMapping =  mapping.node.systemPath.join('.') +"."+ mapping.node.instance.name
			val platformNameWithinMapping = mapping.device.fromPlatform.name
			
			// get the process name of the mappings node
			val processNameOfNodeWithinMapping = nodeNameToProcessNamePairs.findFirst[key.equals(nodeNameWithinMapping)]?.value
			// get platform of process
			val platformNameOfProcess = processNameToPlatformNamePairs.findFirst[key.equals(processNameOfNodeWithinMapping)]?.value
			// check if platform in mapping is the same as the platform of the process
			if(!platformNameWithinMapping.equals(platformNameOfProcess)) {
				// Error nodes process does not run on specified platform 
				error('''The process of node "«nodeNameWithinMapping»" does not run on the specified platform "«platformNameWithinMapping»"''',
					mapping,
					FetamlPackage::Literals::FUNCTION_MAPPING__DEVICE,
					"ProcessIsNotMappedToPropperPlatform"
				)
			}
		]
	}
	
	@Check
	def errorAllNodesOfAnSystemInstanceHaveToBeAssignedToSomeProcess(DeploymentDefinition definition) {
		val referencedNodes = definition.processes.flatMap[nodes].map[node|
			node.instance
		]
		
		definition.systems.forEach[system, featureIndex| 
			val sysInstance = SystemInstance::fromFetaML(system)
			
			sysInstance.allNodeInstancesInSystemHierarchy.forEach[systemNodeInstance|
				if(!referencedNodes.contains(systemNodeInstance.nodeInstance)) {
					val name = systemNodeInstance.qualifiedNameParts.join('.')
				
					error('''The systems node instance "«name»" must be assigned to a process''',
						FetamlPackage::Literals::DEPLOYMENT_DEFINITION__SYSTEMS,
						featureIndex,
						"SystemsNodeInstanceNotAssignedToProcess"
					)
				}
			]
		]
	}
}
