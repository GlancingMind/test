package org.xtext.fetaml.cpp.system

import java.util.Optional
import static extension org.xtext.fetaml.extensions.PortExtensions.*
import org.xtext.fetaml.extensions.PortExtensions.PortProviderType
import org.xtext.fetaml.fetaml.NodeInstance
import org.eclipse.xtend.lib.annotations.EqualsHashCode
import org.xtext.fetaml.model.CasedString
import org.xtext.fetaml.fetaml.PortReference
import org.xtext.fetaml.cpp.pkg.launch.action.LaunchAction
import org.xtext.fetaml.fetaml.PlatformInstance

@EqualsHashCode
class SystemInstance implements PortProviderInstance {
	
	val org.xtext.fetaml.fetaml.SystemInstance definition
	package val CasedString name
	val Optional<SystemInstance> superSystem
	
	static def fromFetaML(org.xtext.fetaml.fetaml.SystemInstance system) {
		new SystemInstance(system)
	}
	
	private new(org.xtext.fetaml.fetaml.SystemInstance system) {
		this(system, Optional::empty)
	}
	
	private new(org.xtext.fetaml.fetaml.SystemInstance system, Optional<SystemInstance> superSystem) {
		this.definition = system
		this.superSystem = superSystem
		this.name = CasedString::tryParse(system.name)
	}
	
	private def getNodeInstances() {
		val nodeInstances = <SystemNodeInstance>newLinkedList
		for(ni : definition.type.nodeInstances) {
			nodeInstances.add(new SystemNodeInstance(this, ni))
		}
		nodeInstances
	}
	
	private def getSubSystems() {
		definition.type.subsystems.map[subSystem|
			new SystemInstance(subSystem, Optional::of(this))
		]
	}
	
	private def getPortGraph() {
		val connections = <PortConnection>newLinkedList
		for(connection : this.definition.type.connections + this.definition.type.forwardings) {
			val p1 = new PortInstance(
					CasedString::tryParse(connection.port1.port.name),
					connection.port1.portProviderInstance,
					connection.port1.port.portType
				)
			val p2 = new PortInstance(
					CasedString::tryParse(connection.port2.port.name),
					connection.port2.portProviderInstance,
					connection.port2.port.portType
				)
			connections.add(new PortConnection(p1, p2))
		}
		
		return new SingleEdgePortGraph(connections)
	}
	
	private def PortProviderInstance getPortProviderInstance(PortReference portRef) {
		if(portRef.isLocalSystemPort) {
			return this
		}
		
		val converter = new FetaMLPortProviderToPortProviderInstance(this)
		return converter.convert(portRef.provider)
	}
	
	override getSuccessor(PortInstance port) {
		this.portGraph.getSuccessor(port)
	}
	
	def boolean usesTopicTools() {
		val root = getRootSystem
		return (#[root] + root.allSubSystems).exists[system|
			!system.portGraph.multiplexers.isEmpty
		]
	}
	
	def Iterable<LaunchAction> getAllLaunchActionsFor(DeploymentInfo deploymentInfo, PlatformInstance platform) {
		val root = getRootSystem
		val muxer = (#[root] + root.allSubSystems).flatMap[system|
			system.portGraph.multiplexers
		]
		return muxer.map[launchConfig]
	}
	
	def Iterable<PortInstance> getPortsFor(PortProviderInstance provider) {
		return this.portGraph.getPortsFor(provider)
	}
	
	def getSystemNodeInstanceForFetaML(NodeInstance ni) {
		allNodeInstancesInSystemHierarchy.findFirst[it.nodeInstance.equals(ni)]
	}
	
	def getAllNodeInstancesInSystemHierarchy() {
		val root = getRootSystem
		val nodes = (#[root] + root.allSubSystems).flatMap[system|
			system.nodeInstances
		]
		return nodes
	}
	
	def Iterable<String> getFullyQualifiedNameParts() {
		this.parentSystemInstances.map[rs| rs.definition.name] + #[this.definition.name]
	}
	
	override Iterable<CasedString> getFullyQualifiedNamePartsAsCasedStrings() {
		this.parentSystemInstances.map[rs| rs.name] + #[this.name]
	}
	
	def Iterable<SystemInstance> getAllSubSystems() {
		this.subSystems + this.subSystems.flatMap[allSubSystems]
	}
	
	private def isRootOfSystemHierarchy() {
		superSystem.isEmpty
	}
	
	def SystemInstance getRootSystem() {
		if(isRootOfSystemHierarchy) {
			return this
		}
		return parentSystemInstance.get.rootSystem
	}
	
	def SystemInstance findSystemInstanceForNodeInstance(NodeInstance ni) {
		getSystemNodeInstanceForFetaML(ni).belongingSystem
	}
	
	package def getSubSystemInstanceByName(String name) {
		subSystems.findFirst[subsysInstance|
			subsysInstance.name.equals(CasedString::tryParse(name))
		]
	}
	
	package def getParentSystemInstance() {
		this.superSystem
	}
	
	def Iterable<SystemInstance> getParentSystemInstances() {
		if(this.isRootOfSystemHierarchy) {
			return #[]
		}
		superSystem.get.parentSystemInstances + #[superSystem.get]
	}
	
	override getName() {
		this.name
	}
	
	override getBelongingSystem() {
		// TODO this might be null!
		this.superSystem.get
	}
	
	override isTypeOf(PortProviderType type) {
		PortProviderType::SystemInstance == type
	}
}