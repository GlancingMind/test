package org.xtext.fetaml.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.xtext.fetaml.fetaml.FunctionMapping
import org.xtext.fetaml.fetaml.Transition
import org.xtext.fetaml.fetaml.StateDefinition
import org.xtext.fetaml.fetaml.PortReference
import org.xtext.fetaml.fetaml.NodeInstance
import org.xtext.fetaml.fetaml.FetamlPackage
import org.xtext.fetaml.fetaml.SystemNodeReference
import org.xtext.fetaml.fetaml.PlatformDeviceReference
import org.xtext.fetaml.cpp.system.SystemInstance
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.EcoreUtil2
import org.xtext.fetaml.fetaml.DeploymentDefinition

/** 
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class FetamlScopeProvider extends AbstractFetamlScopeProvider {
	
	override getScope(EObject context, EReference ref) {
		switch(context) {
			PortReference case ref == FetamlPackage::Literals::PORT_REFERENCE__PORT: {
				scope_PortReference_port(context, ref)
			}
			SystemNodeReference case ref == FetamlPackage::Literals::SYSTEM_NODE_REFERENCE__FROM_SYSTEM: {
				scope_SystemNodeReference_fromSystem(context, ref)
			}
			SystemNodeReference case ref == FetamlPackage::Literals::SYSTEM_NODE_REFERENCE__FROM_SUB_SYSTEMS: {
				scope_SystemNodeReference_fromSubSystems(context, ref)
			}
			SystemNodeReference case ref == FetamlPackage::Literals::SYSTEM_NODE_REFERENCE__INSTANCE: {
				scope_SystemNodeReference_instance(context, ref)
			}
			PlatformDeviceReference case ref == FetamlPackage::Literals::PLATFORM_DEVICE_REFERENCE__INSTANCE: {
				scope_PlatformDeviceReference_instance(context, ref)
			}
			FunctionMapping case ref == FetamlPackage::Literals::FUNCTION_MAPPING__NODE_FUNCTION: {
				scope_FunctionMapping_nodeFunction(context, ref)
			}
			FunctionMapping case ref == FetamlPackage::Literals::FUNCTION_MAPPING__DEVICE_FUNCTION: {
				scope_FunctionMapping_deviceFunction(context, ref)
			}
			Transition case ref == FetamlPackage::Literals::EVENT: { 
				scope_Transition_event(context, ref)
			}
			default:
				super.getScope(context, ref)
		}
	}
	
	private def IScope scope_PortReference_port(PortReference portRef, EReference reference) {
		if(portRef.isPortFromSomeProvider) {
			val provider = portRef.provider
			switch(provider) {
				NodeInstance: return Scopes::scopeFor(provider.type.dataPorts + provider.type.servicePorts)
				org.xtext.fetaml.fetaml.SystemInstance: return Scopes::scopeFor(provider.type.dataPorts + provider.type.servicePorts)
			}
		}
		
		// No SystemReference nor NodeInstance was given. Therefore return default scope
		// which provides enclosing SystemDefinitions node instances, subsystems and ports.
		return super.getScope(portRef, reference)
	}
	
	private def IScope scope_SystemNodeReference_fromSystem(SystemNodeReference nodeRef, EReference reference) {
		
		// TODO ECoreUtils::getDeployment
		// Find all systems and subsystems and return them
		val deployment = EcoreUtil2::getContainerOfType(nodeRef, DeploymentDefinition)
		val deployedSystems = deployment.systems
		val allSystemInstances = deployedSystems.flatMap[SystemInstance::fromFetaML(it).allSubSystems]
		
		val names = allSystemInstances.toMap([systemInstance], [QualifiedName.create(fullyQualifiedNameParts)])
		return Scopes::scopeFor(
			names.keySet,
			[si| names.get(si)],
			IScope::NULLSCOPE
		)
	}
	
	private def IScope scope_SystemNodeReference_fromSubSystems(SystemNodeReference nodeRef, EReference reference) {		
//		val rootSystem = nodeRef?.fromSystem
//		if(rootSystem.name === null) {
//			return IScope::NULLSCOPE
//		}
//		if(nodeRef?.fromSubSystems.isNullOrEmpty) {
//			return Scopes::scopeFor(rootSystem.type.subsystems)
//		}
//		if(nodeRef.fromSubSystems.last.name === null) {
//			return Scopes::scopeFor(rootSystem.type.subsystems)
//		}
		
		val rootSystem = nodeRef?.fromSystem
		if(rootSystem.name === null) {
			return IScope::NULLSCOPE
		}
		val allSubSystemsInSystemHierarchy = SystemInstance::fromFetaML(rootSystem).allSubSystems
		val names = allSubSystemsInSystemHierarchy.toMap([systemInstance], [QualifiedName.create(fullyQualifiedNameParts.tail)])
		return Scopes::scopeFor(
			names.keySet,
			[si| names.get(si)],
			IScope::NULLSCOPE
		)
	}
	
	private def IScope scope_SystemNodeReference_instance(SystemNodeReference nodeRef, EReference reference) {		
		val systemInstance = nodeRef?.fromSystem
		if(systemInstance.name === null) {
			return IScope::NULLSCOPE
		}
		Scopes::scopeFor(systemInstance.type.nodeInstances)
		
//		val sys = SystemInstance::fromFetaML(systemInstance)
//		val allReferenceableNodeInstances = sys.allNodeInstancesInSystemHierarchy
//		val qualifiedNamesForNI = allReferenceableNodeInstances.map[ni|
//			// compute the qualified name of the nodeInstance
//			// e.g. system.subSystem.subSystem.nodeInstance
//			// But, if the nodeInstance is not part of a subSystem, then the
//			// system part isn't considered for the qualified name.
//			// Otherwise the system would show up twice within a SystemNodeReference. 
//			// First for the fromSystem feature of the SystemNodeReference itself
//			// and a second time via the constructed qualified name!
//			// This is quiet a workaround, see comment about the SystemNodeReference 
//			// in the Grammar file.
//			val partsWithoutRootSystemName = ni.qualifiedNameParts.tail
//			if(partsWithoutRootSystemName.empty) {
//				return ni.nodeInstance -> QualifiedName.create(ni.qualifiedNameParts) 	
//			}
//			return ni.nodeInstance -> QualifiedName.create(partsWithoutRootSystemName)
//		].toList
//		
//		val nodeInstances = qualifiedNamesForNI.map[key].toList
//		return Scopes::scopeFor(
//			nodeInstances,
//			[nodeInstance|
//				// Use the constructed qualified name of the node instance
//				// (e.g. system.subSystem.subSystem.nodeInstance)
//				// rather than the instance name.
//				val pair = qualifiedNamesForNI.findFirst[key.equals(nodeInstance)]
//				println(pair)
//				println(qualifiedNamesForNI)
//				qualifiedNamesForNI.remove(pair)
//				println(qualifiedNamesForNI)
//				val qn = pair?.value
//				return qn
//			],
//			IScope::NULLSCOPE
//		)
	}
	
	private def IScope scope_PlatformDeviceReference_instance(PlatformDeviceReference deviceRef, EReference reference) {
		val devices = deviceRef?.fromPlatform?.type?.devices
		if (!devices.isNullOrEmpty) {
			return Scopes::scopeFor(devices)
		}
		return super.getScope(deviceRef, reference)
	}
	
	private def IScope scope_FunctionMapping_nodeFunction(FunctionMapping map, EReference reference) {
		val functions = map?.node?.instance?.type?.functions
		if (!functions.isNullOrEmpty) {
			return Scopes::scopeFor(functions)
		}
		return super.getScope(map, reference)
	}
	
	private def IScope scope_FunctionMapping_deviceFunction(FunctionMapping map, EReference reference) {
		val deviceType = map?.device?.instance?.type
		if (deviceType !== null) {
			return Scopes::scopeFor(deviceType.userCalledFunctions + deviceType.deviceCalledFunctions)
		}
		return super.getScope(map, reference)
	}
	
	private def IScope scope_Transition_event(Transition transition, EReference reference) {
		val events = (transition.eContainer as StateDefinition)?.events
		if (!events.isNullOrEmpty) {
			return Scopes::scopeFor(events)
		}
		return super.getScope(transition, reference)
	}
}
