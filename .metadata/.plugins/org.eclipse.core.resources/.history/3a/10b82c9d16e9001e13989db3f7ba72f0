package org.xtext.fetaml.cpp.system

import java.util.Optional
import static extension org.xtext.fetaml.extensions.PortExtensions.*
import org.xtext.fetaml.extensions.PortExtensions.PortProviderType
import org.xtext.fetaml.fetaml.NodeInstance
import org.eclipse.xtend.lib.annotations.EqualsHashCode
import org.xtext.fetaml.model.CasedString
import org.xtext.fetaml.fetaml.PortReference
import org.xtext.fetaml.cpp.pkg.launch.action.LaunchAction
import org.xtext.fetaml.fetaml.PlatformInstance
import org.xtext.fetaml.fetaml.PortProvider

@EqualsHashCode
class SystemInstance implements PortProviderInstance {
	
	val org.xtext.fetaml.fetaml.SystemInstance definition
	package val CasedString name
	val Optional<SystemInstance> superSystem
	
	static def fromFetaML(org.xtext.fetaml.fetaml.SystemInstance system) {
		new SystemInstance(system)
	}
	
	private new(org.xtext.fetaml.fetaml.SystemInstance system) {
		this(system, Optional::empty)
	}
	
	private new(org.xtext.fetaml.fetaml.SystemInstance system, Optional<SystemInstance> superSystem) {
		this.definition = system
		this.superSystem = superSystem
		this.name = CasedString::tryParse(system.name)
	}
	
	private def getNodeInstances() {
		val nodeInstances = <SystemNodeInstance>newLinkedList
		for(ni : definition.type.nodeInstances) {
			nodeInstances.add(new SystemNodeInstance(this, ni))
		}
		nodeInstances
	}
	
	private def getSubSystems() {
		definition.type.subsystems.map[subSystem|
			new SystemInstance(subSystem, Optional::of(this))
		]
	}
	
	private def getPortGraph() {
		val connections = <PortConnection>newLinkedList
		for(connection : this.definition.type.connections + this.definition.type.forwardings) {
			val p1 = new PortInstance(
					CasedString::tryParse(connection.port1.port.name),
					connection.port1.portProviderInstance,
					connection.port1.port.portType
				)
			val p2 = new PortInstance(
					CasedString::tryParse(connection.port2.port.name),
					connection.port2.portProviderInstance,
					connection.port2.port.portType
				)
			connections.add(new PortConnection(p1, p2))
		}
		
		return new SingleEdgePortGraph(connections)
	}
	
	private def PortProviderInstance getPortProviderInstance(PortReference portRef) {
		if(portRef.isLocalSystemPort) {
			return this
		}
		
		val converter = new FetaMLPortProviderToPortProviderInstance(this)
		return converter.convert(portRef.provider)
	}
	
	override getSuccessor(PortInstance port) {
		this.portGraph.getSuccessor(port)
	}
	
	// TODO exposing this methode is a workaround to allow the registration of the topic_tools package as dependency to the package-manifest
	def boolean usesTopicTools() {
		val root = getRootSystem
		return (#[root] + root.allSubSystems).exists[system|
			!system.portGraph.multiplexers.isEmpty
		]
	}
	
	def Iterable<LaunchAction> getAllLaunchActionsFor(PlatformInstance platform, DeploymentInfo deploymentInfo) {
		val root = getRootSystem
		val muxer = (#[root] + root.allSubSystems).flatMap[system|
			system.portGraph.multiplexers
		]
		return muxer.filter[determineExecutionEnvironment(deploymentInfo).equals(platform)].map[launchConfig]
	}
	
	private def determineExecutionEnvironment(MultiplexerNodeInstance mni, DeploymentInfo deploymentInfo) {
		// TODO "mni.successorOfOutputPort.provider" will also return a system if the port is a system port!
		// Which wont result in the proper behaviour.
//		val providerOfConnectedOutputPort = mni.successorOfOutputPort.provider
//		val outPortNodeInstance = deploymentInfo.allDeployedNodeInstances.findFirst[ni|
//			providerOfConnectedOutputPort.isInstanceOfFetaML(ni)
//		]
//		val outPlatform = deploymentInfo.getExecutionEnvironmentFor(outPortNodeInstance)
		
		val inPortNodeInstances = deploymentInfo.allDeployedNodeInstances.filter[ni|
			mni.successorsOfInputPorts.exists[ip| ip.provider.isInstanceOfFetaML(ni)]
		]
		val inPlatforms = inPortNodeInstances.map[ip| deploymentInfo.getExecutionEnvironmentFor(ip)]
		
		val platforms = inPlatforms //+ #[outPlatform]
		val platformCount = <PlatformInstance, Integer>newHashMap
		for(platform : platforms) {
			val occurences = platformCount.getOrDefault(platform, 0)
			platformCount.put(platform, occurences+1)
		}
		val executionEnvironment = platformCount.entrySet.sortBy[it.value].head.key
		return executionEnvironment
	}
	
	def Iterable<PortInstance> getPortsFor(PortProviderInstance provider) {
		return this.portGraph.getPortsFor(provider)
	}
	
	def getSystemNodeInstanceForFetaML(NodeInstance ni) {
		allNodeInstancesInSystemHierarchy.findFirst[it.nodeInstance.equals(ni)]
	}
	
	def getAllNodeInstancesInSystemHierarchy() {
		val root = getRootSystem
		val nodes = (#[root] + root.allSubSystems).flatMap[system|
			system.nodeInstances
		]
		return nodes
	}
	
	def Iterable<String> getFullyQualifiedNameParts() {
		this.parentSystemInstances.map[rs| rs.definition.name] + #[this.definition.name]
	}
	
	override Iterable<CasedString> getFullyQualifiedNamePartsAsCasedStrings() {
		this.parentSystemInstances.map[rs| rs.name] + #[this.name]
	}
	
	def Iterable<SystemInstance> getAllSubSystems() {
		this.subSystems + this.subSystems.flatMap[allSubSystems]
	}
	
	private def isRootOfSystemHierarchy() {
		superSystem.isEmpty
	}
	
	def SystemInstance getRootSystem() {
		if(isRootOfSystemHierarchy) {
			return this
		}
		return parentSystemInstance.get.rootSystem
	}
	
	def SystemInstance findSystemInstanceForNodeInstance(NodeInstance ni) {
		getSystemNodeInstanceForFetaML(ni).belongingSystem
	}
	
	package def getSubSystemInstanceByName(String name) {
		subSystems.findFirst[subsysInstance|
			subsysInstance.name.equals(CasedString::tryParse(name))
		]
	}
	
	package def getParentSystemInstance() {
		this.superSystem
	}
	
	def Iterable<SystemInstance> getParentSystemInstances() {
		if(this.isRootOfSystemHierarchy) {
			return #[]
		}
		superSystem.get.parentSystemInstances + #[superSystem.get]
	}
	
	override getName() {
		this.name
	}
	
	override getBelongingSystem() {
		// TODO this might be null!
		this.superSystem.get
	}
	
	override isTypeOf(PortProviderType type) {
		PortProviderType::SystemInstance == type
	}
	
	override isInstanceOfFetaML(PortProvider provider) {
		this.definition.equals(provider)
	}
}